<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- 引入样式文件 -->
	   <link rel="stylesheet" href="https://unpkg.com/vant@2.12/lib/index.css" /> 
		<!-- 引入 Vue 和 Vant 的 JS 文件 -->
		<script src="https://unpkg.com/vue@2.6/dist/vue.min.js"></script> 

		<script src="https://unpkg.com/vant@2.12/lib/vant.min.js"></script>

<script>
setButtonImage('http://q1.qlogo.cn/qhis/Q3auHgzwzM4MyXVOBDnnp5Q6zPxeDjgRwtKAdqgkiadLUMq9uY40ZGXekSeHrFmUEQQll8kw6ia3ou0eGsAfdvSw/640');  
</script>  
<script>
window.onload = () => alert("公益版本倒卖sm Q：756323586");
</script>  

		<style>
			* {
				padding: 0;
				margin: 0;
			}

			/*菜单*/
			*:not(input, checkbox, textarea) {
				/*禁止文本选择*/
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				user-select: none;
				/* Non-prefixed version, currently */
			}

			.aymenu {
				position: fixed;
				width: 300px;
				height: 477px;
				top: calc(50% - 180px);
				left: calc(50% - 180px);
				z-index: 999;
				background-color: #f2f1f6;
				/*背景*/
				border-radius: 14px;
				/*圆角*/
				overflow: hidden;
				-webkit-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
			}

			.van-tab {
				font-size: 15px;
			}

			.van-cell {
				position: relative;
				display: -webkit-box;
				display: -webkit-flex;
				display: flex;
				box-sizing: border-box;
				width: 100%;
				padding: 10px 16px;
				overflow: hidden;
				color: #323233;
				font-size: 15px;
				line-height: 24px;
				background-color: #fff;
			}

			.van-nav-bar__title {
				max-width: 60%;
				margin: 0 auto;
				color: #323233;
				font-weight: 500;
				font-size: 16px;
				font-weight: 800;
			}

			.fun-block__title {
				margin: 0;
				padding: 32px 32px 5px;
				color: rgba(69, 90, 100, 0.6);
				font-weight: normal;
				font-size: 14px;
				line-height: 16px;
			}

			.van-cell {
				line-height: unset;
			}

			.menuBody {
				overflow-y: auto;
				padding-bottom: 46px;
			}

			.custom-button {
				width: 26px;
				color: #fff;
				font-size: 10px;
				line-height: 18px;
				text-align: center;
				border-radius: 100px;
				background-color: #1989fa;
			}

			.van-stepper--round .van-stepper__minus {
				color: #fff;
				background-color: #1989fa;
				border: 1px solid #1989fa;
			}

			.van-stepper--round .van-stepper__plus {
				color: #fff;
				background-color: #1989fa;
			}

			.van-cell-group.van-cell-group--inset.van-hairline--top-bottom {
				border-radius: 10px;
				/*圆角*/
			}

			.van-hairline--top-bottom::after,
			.van-hairline-unset--top-bottom::after {
				border-width: 0px 0;
			}

			.van-tabs__nav--card {
				/*滑块*/
				box-sizing: border-box;
				height: 30px;
				margin: 0 0px;
				border: 2px solid #e9e9eb;
			}

			.van-tabs__nav--card2 {
				/*滑块*/
				box-sizing: border-box;
				height: 30px;
				margin: 0 16px;
				border: 2px solid #e9e9eb;
			}

			.van-tabs__nav--card .van-tab.van-tab--active,
			.van-tabs__nav--card2 .van-tab.van-tab--active {
				border-radius: 6px;
				color: #323233;
				background-color: #ffffff;
				font-weight: 600;
			}

			.van-tabs__nav--card .van-tab,
			.van-tabs__nav--card2 .van-tab {
				color: #969799;
				border-right: 0px solid #969799;
				font-weight: 450;
			}

			.van-tabs__nav--card .van-tab.van-tab--active,
			.van-tabs__nav--card2 .van-tab.van-tab--active {
				border-radius: 6px;
				color: #323233;
				background-color: #ffffff;
			}

			.van-tabs__nav--card .van-tab,
			.van-tabs__nav--card2 .van-tab {
				color: #969799;
				border-right: 0px solid #969799;
			}

			.van-tabs__nav {
				position: relative;
				display: -webkit-box;
				display: -webkit-flex;
				display: flex;
				background-color: #e9e9eb;
				-webkit-user-select: none;
				user-select: none;
				border-radius: 7px;
			}

			.van-cell {
				position: relative;
				display: -webkit-box;
				display: -webkit-flex;
				display: flex;
				box-sizing: border-box;
				width: 100%;
				height: 45px;
				padding: 10px 16px;
				overflow: hidden;
				color: #323233;
				font-size: 15px;
				line-height: 24px;
				background-color: #ffffff;
				font-weight: 600;
				/*加粗*/
			}

			.van-switch {
				position: relative;
				display: inline-block;
				box-sizing: content-box;
				width: 50px;
				height: 30px;
				font-size: 30px;
				background-color: #fff;
				border: 1px solid #fff;
				border-radius: 1em;
				cursor: pointer;
				-webkit-transition: background-color .3s;
				transition: background-color .3s;
			}

			.van-switch__node {
				position: absolute;
				font-size: 20px;
				top: 2px;
				left: 2px;
				width: 26px;
				height: 26px;
				font-size: inherit;
				background-color: #fff;

				box-shadow: 0 3px 1px 0 rgb(0 0 0 / 2%), 0 2px 2px 0 rgb(0 0 0 / 5%), 0 3px 3px 0 rgb(0 0 0 / 5%);
				-webkit-transition: -webkit-transform .3s cubic-bezier(.3, 1.05, .4, 1.05);
				transition: -webkit-transform .3s cubic-bezier(.3, 1.05, .4, 1.05);
				transition: transform .3s cubic-bezier(.3, 1.05, .4, 1.05);
				transition: transform .3s cubic-bezier(.3, 1.05, .4, 1.05), -webkit-transform .3s cubic-bezier(.3, 1.05, .4, 1.05);
			}

			.van-stepper__minus,
			.van-stepper__plus {
				position: relative;
				box-sizing: border-box;
				width: 28px;
				height: 28px;
				margin: 0;
				padding: 0;
				color: #323233;
				vertical-align: middle;
				background-color: #e9e9eb;
				border: 0;
				cursor: pointer;
			}

			.van-stepper__input {
				box-sizing: border-box;
				width: 32px;
				height: 28px;
				margin: 0 0px;
				padding: 0;
				color: #323233;
				font-size: 14px;
				line-height: normal;
				text-align: center;
				vertical-align: middle;
				background-color: #e9e9eb;
				border: 0;
				border-width: 1px 0;
				border-radius: 0;
			}

			.van-stepper__minus::before,
			.van-stepper__plus::before {
				width: 50%;
				height: 2px;
			}

			.van-stepper__minus::after,
			.van-stepper__plus::after {
				width: 2px;
				height: 50%;
			}

			.van-slider__button {
				width: 24px;
				height: 24px;
				background-color: #fff;
				border-radius: 50%;
				box-shadow: 0 2px 5px rgb(0 0 0 / 20%);
			}

			.van-nav-bar {
				position: relative;
				z-index: 1;
				line-height: 22px;
				text-align: center;
				background-color: #f2f1f6;
				-webkit-user-select: none;
				user-select: none;
			}

			.van-cell::after {
				position: absolute;
				box-sizing: border-box;
				content: ' ';
				pointer-events: none;
				right: 0px;
				bottom: 0;
				left: 16px;
				border-bottom: 0.8px solid #cacaca;
				-webkit-transform: scaleY(.5);
				transform: scaleY(.5);
			}

			.van-collapse-item--border::after {
				position: absolute;
				box-sizing: border-box;
				content: ' ';
				pointer-events: none;
				top: 0;
				right: 0px;
				left: 16px;
				border-top: 0.8px solid #cacaca;
				-webkit-transform: scaleY(.5);
				transform: scaleY(.5);
			}

			.van-radio__icon--checked .van-icon {
				color: #c1c1c1;
				background-color: #ffffff00;
				border-color: #c1c1c1;
			}

			.van-stepper__minus {
				border-radius: 5px 0 0 5px;
			}

			.van-stepper__plus {
				border-radius: 0 5px 5px 0;
			}

			.van-hairline--bottom::after {
				border-bottom-width: 0px;
			}

			.van-collapse-item__title .van-cell__right-icon::before {
				-webkit-transform: rotate(0deg) translateZ(0);
				transform: rotate(0deg) translateZ(0);
				-webkit-transition: -webkit-transform .3s;
				transition: -webkit-transform .3s;
				transition: transform .3s;
				transition: transform .3s, -webkit-transform .3s;
			}

			.van-collapse-item__title--expanded .van-cell__right-icon::before {
				-webkit-transform: rotate(90deg);
				transform: rotate(90deg);
			}
		</style>
	</head>
	<body>
		<div id="app">
			<div class="aymenu" ref="menuMain">
				<div @touchstart="titleTouchStart" @touchmove="titleTouchMove">
					<van-nav-bar title="GB三角洲公益">
						<template #right>
							<van-icon @click="closeMenu" name="close" size="24" color="#c1c1c1" />
						</template>
					</van-nav-bar>
				</div>
				<div class="menuBody" ref="menuBody">
					<van-cell-group inset>
						<van-cell center title="绘制开关">
							<template #right-icon>
								<van-tabs v-model="checkboxList.isDraw" type="card" style="width: 60%;">
									<van-tab title="开启" name="1"></van-tab>
									<van-tab title="关闭" name="2"></van-tab>
								</van-tabs>
							</template>
						</van-cell>
						<!--<van-cell center title="主播模式">
							<template #right-icon>
								<van-tabs v-model="isLive" @change="changeLive" type="card" style="width: 60%;">
									<van-tab title="开启" name="1"></van-tab>
									<van-tab title="关闭" name="2"></van-tab>
								</van-tabs>
							</template>
						</van-cell> -->
					</van-cell-group>

					<br>
					<van-cell-group inset>
						<van-collapse v-model="active" accordion>
							<van-collapse-item title="绘制">
								<van-cell center title="射线">
									<template #right-icon>
										<van-switch v-model="checkboxList.isLine" size="20" active-color="#34c85a"
													inactive-color="#e9e9eb" />
									</template>
								</van-cell>
								<van-cell center title="方框">
									<template #right-icon>
										<van-switch v-model="checkboxList.isBox" size="20" active-color="#34c85a"
													inactive-color="#e9e9eb" />
									</template>
								</van-cell>
								<van-cell center title="血量">
									<template #right-icon>
										<van-switch v-model="checkboxList.isHP" size="20" active-color="#34c85a"
													inactive-color="#e9e9eb" />
									</template>
								</van-cell>
								<van-cell center title="信息">
									<template #right-icon>
										<van-switch v-model="checkboxList.isInfo" size="20" active-color="#34c85a"
													inactive-color="#e9e9eb" />
									</template>
								</van-cell>
								<van-cell center title="距离">
									<template #right-icon>
										<van-switch v-model="checkboxList.isDis" size="20" active-color="#34c85a"
													inactive-color="#e9e9eb" />
									</template>
								</van-cell>
								<van-cell center title="手持">
									<template #right-icon>
										<van-switch v-model="checkboxList.isShouChi" size="20" active-color="#34c85a"
													inactive-color="#e9e9eb" />
									</template>
								</van-cell>
							</van-collapse-item>
						</van-collapse>
					</van-cell-group>
					<br>
					<van-cell-group inset>
					  <van-collapse v-model="active2" accordion>
						<van-collapse-item title="绘图参数">
							<van-cell center title="观透队标">
								<template #right-icon>
									<van-slider v-model="team" :min="0" :max="100" bar-height="3px"
												style="width: 63%;">
										<template #button>
											<div class="custom-button">{{team}}</div>
										</template>
									</van-slider>
								</template>
							</van-cell>
							<van-cell center title="顶部距离">
								<template #right-icon>
									<van-slider v-model="renshu" :min="0" :max="100" bar-height="3px"
												style="width: 63%;">
										<template #button>
											<div class="custom-button">{{renshu}}</div>
										</template>
									</van-slider>
								</template>
							</van-cell>
							<van-cell center title="线条粗细">
								<template #right-icon>
									<van-stepper v-model="xian" min="1" max="10" theme="round" button-size="22"
												 disable-input />
								</template>
							</van-cell>
						 </van-collapse-item>
					  </van-collapse>
					</van-cell-group>
					<br>
					<van-cell-group inset>
						<van-collapse v-model="active3" accordion>
							<van-collapse-item title="漏打">
								<van-cell center title="自瞄漏打">
									<template #right-icon>
										<van-switch v-model="checkboxList.iszimiao size="20" active-color="#34c85a"
													inactive-color="#e9e9eb" />
									</template>
								</van-cell>
							</van-collapse-item>
						</van-collapse>
					</van-cell-group>
				</div>
			</div>
		</div>
	</body>
	<script>
		let app = new Vue({
					el: '#app',
					data() {
						return {
							active: false,
							active1: false,
							active2: false,
							active3: false,
							active4: false,
		
							checkboxList: {
								isDraw: '2', //开关
								isLine: true, //射线
								isBox: true, //方框
								isBone: false, //骨骼
								isHP: true, //血量
								isInfo: true, //信息
								isDis: true, //距离
								isShouChi: true, //手持
								isBeid: false, //背敌
								isleida: false, //雷达
								iswuqixs: false,//武器显示
								isduiyou: true,//排除队友
								isvehicle: false, //载具
								ishezi: false, //盒子
								iszimiao:false, //漏打
							},
							
							renshu: 40, //人数
							xian: 2, //线条
							isLive: '2', //直播开关
							leida: '3', //雷达大小
							tietu: '2', //贴图开关
							huizhi: '1', //绘制风格
							guge: 'qg', //骨骼风格
							fangkuang: '1', //方框风格
							fps: '21', //绘制帧率
							dis: '500', //绘制范围
							zaijufw: '500', //载具范围
							gugefw: '100', //骨骼范围
							team: '0', //观战队标
		
							teamcolor: { //队标颜色
								1: '#DC143C',
								2: '#FFB6C1',
								3: '#FF69B4',
								4: '#FF00FF',
								5: '#7B68EE',
								6: '#F58220',
								7: '#6495ED',
								8: '#1E90FF',
								9: '#426ab3',
								10: '#00FFFF',
								11: '#7FFFD4',
								12: '#90EE90',
								13: '#FFFF00',
								14: '#F0E68C',
								15: '#FFA500',
								16: '#FF8C00',
								17: '#8B4513',
								18: '#FF6347',
								19: '#CD5C5C',
								20: '#C0C0C0',
								21: '#696969',
								22: '#66CDAA',
								23: '#FFD700',
								24: '#FFE4E1',
								25: '#8B008B',
								26: '#5C2223',
								27: '#482936',
								28: '#C45A65',
								29: '#440E25',
								30: '#36292F',
								31: '#5D3F51',
								32: '#681752',
								33: '#3E3841',
								34: '#ED556A',
								35: '#7A7374',
								36: '#EA517F',
								37: '#3161AB',
								38: '#2474B5',
								39: '#93B5CF',
								40: '#2177B8',
								41: '#2D2E36',
								42: '#5E6E6D',
								43: '#61649F',
								44: '#475164',
								45: '#2B333E',
								46: '#15559A',
								47: '#5E7987',
								48: '#74787A',
								49: '#1781B5',
								50: '#BBB5AC',
								51: '#FF9900',
								52: '#AD9E5F',
								53: '#DC9123',
								54: '#97846C',
								55: '#E3BD8D',
								56: '#4D4030',
								57: '#F8C387',
								58: '#FA7E23',
								59: '#E2D849',
								60: '#5E5314',
								61: '#AD9E5F',
								62: '#FED71A',
								63: '#E4BF11',
								64: '#D2B42C',
								65: '#F8DF72',
								66: '#DDC871',
								67: '#93D5DC',
								68: '#57C3C2',
								69: '#1BA784',
								70: '#428675',
								71: '#69A794',
								72: '#FF7F50',
								73: '#E9967A',
								74: '#B8860B',
								75: '#DAA520',
								76: '#F0E68C',
								77: '#9ACD32',
								78: '#00FA9A',
								79: '#66CDAA',
								80: '#2F4F4F',
								81: '#5F9EA0',
								82: '#5F9EA0',
								83: '#6495ED',
								84: '#87CEFA',
								85: '#F5DEB3',
								86: '#FFFACD',
								87: '#D2691E',
								88: '#CD853F',
								89: '#DEB887',
								90: '#BC8F8F',
								91: '#FFDEAD',
								92: '#FFE4E1',
								93: '#FFEFD5',
								94: '#F5FFFA',
								95: '#E6E6FA',
								96: '#F0FFF0',
								97: '#DCDCDC',
								98: '#D8BFD8',
								99: '#B22222',
								100: '#808080',
							},
		
							
		
							shouchi: { //手持
								0: '拳头',
								101001: 'AKM',
								101002: 'M16A4',
								101003: 'SCAR-L',
								101004: 'M416',
								101005: 'GROZA',
								101006: 'AUG',
								101007: 'QBZ',
								101008: 'M762',
								101009: 'Mk47',
								101010: 'G36C',
								101011: 'AC-VAL',
								101012: '蜜獾',
								102001: 'UZI',
								102002: 'UMP45',
								102003: 'Vector',
								102004: '汤姆逊',
								102005: '野牛',
								102007: 'MP5K',
								102105: 'P90',												
								103002: 'M24',
								103003: 'AWM',
								103004: 'SKS',
								103005: 'VSS',
								103006: 'Mini14',
								103007: 'Mk14',
								103009: 'SLR',						
								103010: 'QBU',
								103011: '莫辛纳甘',
								103013: 'M417',
								103014: 'MK20-H',
		                        103015: 'M200',						
								103001: 'Kar98K',
								103008: 'Win94',
								103012: 'AMR',
								103901: 'Kar98K',
								103903: 'AWM',
								103905: 'M200',
								104001: 'S686',
								104002: 'S1897',
								104003: 'S12K',
								104004: 'DBS',
								104100: 'SPAS-12',
								105001: 'M249',						
								105002: 'DP-28',												
								105010: 'MG3',
								105012: 'PKM',																																										
								106001: 'P92',
								106002: 'P1911',
								106003: 'R1895',
								106004: 'P18C',
								106005: 'R45',
								106006: '散弹手枪',
								106008: '蝎式手枪',
								106010: '沙漠之鹰',
								106011: 'TMP-9手枪',
								107001: '十字弩',
								107006: '战术弩',
								107007: '爆炸猎弓',
								107010: '突击盾牌',
								108001: '大砍刀',
								108002: '撬棍',
								108003: '镰刀',
								108004: '平底锅',
								602004: '手榴弹',
								602001: '震爆弹',
								602002: '烟雾弹',
								602003: '燃烧瓶',
								602075: '铝热弹',
								
							},
						}
					},
					mounted() {
						this.setRect(370, 355);
					},
					methods: {
						setRect(w, h, x = -1, y = -1) {
							var boxW = w;
							var boxH = h;
		
							var ayMenu = this.$refs.menuMain;
							ayMenu.style.width = `${boxW}px`;
							ayMenu.style.height = `${boxH}px`;
							if (x == -1) ayMenu.style.left = `calc(50% - ${boxW / 2}px)`;
							if (y == -1) ayMenu.style.top = `calc(50% - ${boxH / 2}px)`;
		
		
							var menuBody = this.$refs.menuBody;
							menuBody.style.height = `${boxH - 46 - 40}px`;
						},
						titleTouchStart(event) {
							this.touchStartX = parseInt(event.touches[0].clientX);
							this.touchStartY = parseInt(event.touches[0].clientY);
		
							var ayMenu = this.$refs.menuMain;
							this.menuLastX = ayMenu.offsetLeft;
							this.menuLastY = ayMenu.offsetTop;
						},
						titleTouchMove(event) {
							event.preventDefault();
							var distanceX = event.touches[0].clientX - this.touchStartX;
							var distanceY = event.touches[0].clientY - this.touchStartY;
		
							var ayMenu = this.$refs.menuMain;
							ayMenu.style.left = this.menuLastX + distanceX + "px";
							ayMenu.style.top = this.menuLastY + distanceY + "px";
						},
		
						closeMenu() {
							var menu = document.querySelector("#app");
							menu.style.display = "none";
							setWindowTouch(false);
						},		
					}
				});
		
				//脚本放在最后面, body加载完之后再执行
				//激活webkit的button:active
				document.body.addEventListener('touchstart', function() {});
				//设置不可拖动
				setWindowDrag(0, 0, 0, 0);
				//设置按照屏幕像素尺寸绘图(高清模式)
				const iosScale = window.devicePixelRatio;
				let sWidth = 0; //屏幕宽
				let sHeight = 0; //屏幕高
				//创建画布，布满整个屏幕
				let canvasDom = document.createElement("canvas");
				document.body.appendChild(canvasDom);
				canvasDom.style.height = "100%";
				canvasDom.style.width = "100%";
				//获取窗口信息
				const layout = function() {
					//window.orientation是设备握持方向, 不是屏幕显示方向
					if (window.lastorientation == window.orientation) return;
					window.lastorientation = window.orientation;
					//window.screen中的宽高不会随着屏幕旋转更新(只会在初始化的时候固定)
					if (Math.abs(window.orientation) == 90) {
						//横屏模式
						setWindowRect(0, 0, window.screen.height, window.screen.width);
						canvasDom.width = window.screen.height * iosScale;
						canvasDom.height = window.screen.width * iosScale;
						sWidth = window.screen.height;
						sHeight = window.screen.width;
					} else {
						//竖屏模式
						setWindowRect(0, 0, window.screen.width, window.screen.height);
						canvasDom.height = window.screen.height * iosScale;
						canvasDom.width = window.screen.width * iosScale;
						sWidth = window.screen.width;
						sHeight = window.screen.height;
					}
				}
		
				layout(); //设置旋转屏幕时自动调整布局和画布
				window.addEventListener("orientationchange", layout, false);
				
				//*设置自定义的悬浮按钮图标点击动作
				setButtonAction(function() {
					let menu = document.querySelector("#app");
					if (menu.style.display == 'none') {
						menu.style.display = 'block';
						//隐藏菜单之后, 设置触控穿透悬浮窗口
						setWindowTouch(true);
					} else {
						menu.style.display = 'none';
						//显示菜单之后, 设置触控不可穿透悬浮窗口
						setWindowTouch(false);
					}
				});
		
				const ctx = canvasDom.getContext('2d');
				setLineWidth(iosScale);
				var fontFamily = " Arial";
				var cacheTimer = null; //数据缓存计时器，减少遍历次数，提高性能
				var drawTimer = null; //绘图计时器，控制帧率
				var actorCache = []; //对象地址缓存
				//获取进程
				let baseAddr = Number(h5gg.getRangesList(0)[0].start); //aslr只读一次，能减少🐔🎱那么一点性能消耗
				let GWorld = 0; //世界全局变量，公用
		
				function drawCache() {
					if (isNull(GWorld)) return;
					const Level = readLong(GWorld + 0xF8); //Level* PersistentLevel
					const ActorArray = readLong(Level + 0x98);
					const ActorCount = readInt(Level + 0x98+8);
					
					//drawText(`对象数量: ${ActorCount}`, sWidth / 5, sHeight / 5, 22, "red", "center", true);
					
					const tempArr = [];
					//遍历
					for (let i = 0; i < ActorCount; i++) {
						const actor = readLong(ActorArray + i * 8); // + 0x10
						if (isNull(actor)) continue;
						const HPmax = readFloat(readLong(actor + 0xE18)+0x210); //float HealthMax;	
						if (HPmax == 100) {
							tempArr.push(actor);
						}
					}
					actorCache = tempArr;
				}
		
				function shadowDraw() {
					clearCtx();
					//世界地址
					GWorld = readLong(baseAddr + 0xf3246b8);
					if (isNull(GWorld)) return;
					//获取自己
					const NetDriver = readLong(GWorld + 0x30); 
					const ServerConnection = readLong(NetDriver + 0x88); 
					const localPlayerController = readLong(ServerConnection + 0x30);

					const STE = readLong(localPlayerController + 0x3A0);

					const StatePoint = readLong(STE + 0x390);
					const Team1 = readInt(StatePoint + 0x62C);
					const Team2 = readInt(StatePoint + 0x630);
					
					const playerCameraManager = readLong(localPlayerController + 0x408); 

					if (isNull(playerCameraManager)) return;
					const povAddr = playerCameraManager + 0x1790; 
					const camViewInfo = {
						Location: {
							X: readFloat(povAddr),
							Y: readFloat(povAddr + 4),
							Z: readFloat(povAddr + 8)
						},
						Rotation: {
							Pitch: readFloat(povAddr + 0xc),
							Yaw: readFloat(povAddr + 0xc+4),
							Roll: readFloat(povAddr + 0xc+8)
						},
						FOV: readFloat(povAddr + 0x18)
					}
					//雷达，获取相机旋转视角
					let camAngle = camViewInfo.Rotation.Yaw;
					//一帧只计算一次，减少性能消耗
					const tempMatrix = RotatorToMatrix(camViewInfo.Rotation);
		
					let playerCout = 0;
					let ai = 0;
					let topEnemy = 0;
					let vehicle = 0;
		
					let zmiaozjjl = 9999;
					let actorbone = 0;
		
					var D2Dtemp = [];
		
					for (let i = 0; i < actorCache.length; i++) {
						//排除自己
						const actor = actorCache[i];
						if (STE == actor) continue;
	
						//排除队友
						const team = readInt(readLong(actor + 0x390) + 0x62C); 
						const team1 = readInt(readLong(actor + 0x390) + 0x62C); 
						const team2 = readInt(readLong(actor + 0x390) + 0x630); 
						
						if (team1 == Team1 || team2 == Team2) continue;
						
						//最大生命值
						const hpmax = readFloat(readLong(actor + 0xE18)+0x210);	
						//获取生命值
						const hp = readFloat(readLong(readLong(actor + 0xE18)+0x238)+0x40);
						if (hp == 0) continue;
						const renhp = hp;
						//获取人物状态
						const StatusOffset = readInt(actor + 0x1378); 
						
						const rootComponent = readLong(actor + 0x180);
						if (isNull(rootComponent)) continue;
						const worldPos = {
							X: readFloat(rootComponent + 0x220),
							Y: readFloat(rootComponent + 0x224),
							Z: readFloat(rootComponent + 0x228)
						}
		
						//计算距离
						const distX = (worldPos.X - camViewInfo.Location.X) / 100;
						const distY = (worldPos.Y - camViewInfo.Location.Y) / 100;
						let distance = (distX * distX) + (distY * distY);
						const distZ = (worldPos.Z - camViewInfo.Location.Z) / 100;
						distance = Math.ceil(Math.sqrt((distZ * distZ) + distance));
						//敌人yaw  单位：角度
						const angleOffset = readFloat(actor + 0xa64);
						//雷达获取敌人世界坐标
						const wradPos = {
							X: distX,
							Y: distY,
							dist: distance
						};
						const wAngle = (180.0 / Math.PI) * Math.atan2(wradPos.Y, wradPos.X); //雷达，角度相关
						const Angle = camAngle - wAngle + 90; //雷达，角度相关
						const towards = angleOffset - camAngle - 90; //雷达敌人视角朝向
		
						//雷达获取敌人屏幕坐标
						const radPos = {
							X: wradPos.dist * Math.cos(Angle / 180.0 * Math.PI),
							Y: wradPos.dist * Math.sin(Angle / 180.0 * Math.PI)
						};
		
						const zb1 = {
							X: worldPos.X,
							Y: worldPos.Y,
							Z: worldPos.Z + 80.0
						}
		
						const zb2 = {
							X: worldPos.X,
							Y: worldPos.Y,
							Z: worldPos.Z - 88.0
						}
		
						//顶部方框线
						const fkzb1 = world2Screen(zb1, camViewInfo, tempMatrix);
						//底部方框线
						const fkzb2 = world2Screen(zb2, camViewInfo, tempMatrix);
						const fkgao = fkzb2.Y - fkzb1.Y;
						const fkkuan = fkgao / 2;
		
						if (!app.zmiaoanj) {
							dx = Math.abs(sWidth / 2 - fkzb1.X);
							dy = Math.abs(sHeight / 2 - fkzb1.Y);
							var d2ddis = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
							if (zmiaozjjl > d2ddis) {
								zmiaozjjl = d2ddis;
								actorbone = actor;
							}
						}
		
						//手持枪械
						const lastUpdateStatusKeyListOffset = 0x2c38; //LastUpdateStatusKeyList
						const equipWeaponOffset = 0x20; //STExtraWeapon* EquipWeapon
						const weaponOffset = lastUpdateStatusKeyListOffset + equipWeaponOffset;
						const weaponIDOffset = 0x9f9; //int RepWeaponID
						const my_weapon = readLong(actor + weaponOffset);
						const weaponid = readInt(my_weapon + weaponIDOffset);

						//自瞄绘图
				if (app.checkboxList.isZimiao) {
				    //圆圈
				    drawCircular(sWidth / 2, sHeight / 2, 100, app.zimiaodx, "red", 1, false);
				if (objectInfo.dis <= app.zimiaojl && objectInfo.x > 0 && objectInfo.y > 0 && objectInfo.x  < sWidth && objectInfo.y < sHeight) {
				    //线条
					drawLine(objectInfo.toux, objectInfo.touy, sWidth / 2, sHeight / 2, "aqua", 2);
					}
				}
		
						if (1) {
							const bIsAI = team2; //bool bIsAI
							//伞兵计数
							if (StatusOffset == 33554448 || StatusOffset == 33554449) topEnemy += 1;
							//读名字可能消耗性能，不需要注释即可⬇️⬇️⬇️⬇️⬇️⬇️
							//只对经典风格生效
							//PlayerName
							let name = "";
							if (app.checkboxList.isInfo) {
								//超出屏幕不计算
								if (fkzb1.X > 0 && fkzb1.Y > 0 && fkzb1.X < sWidth && fkzb1.Y < sHeight) {
									const nameAddr = readLong(readLong(actor + 0x390)+0x470);
									name = nameAddr.toString(16);
									if (!isNull(nameAddr)) {
										name = "";
										for (let s = 0; s < 14; s++) {
											const after = Number(h5gg.getValue(nameAddr + s * 2, "U8")).toString(16).padStart(2, '0');
											const before = Number(h5gg.getValue(nameAddr + s * 2 + 1, "U8")).toString(16).padStart(2,
												'0');
											const charCode = before + after;
											if (charCode == "0000") break;
											name += String.fromCharCode(parseInt(charCode, 16));
										}
									}
								}
							}
							//读名字可能消耗性能，不需要注释即可⬆️⬆️⬆️⬆️⬆️⬆️
		
							/***************骨骼函数*******************/
							
		
							//记录要绘制的全部信息
							const actorInfo = {
								x: fkzb1.X, //x坐标
								y: fkzb1.Y, //y坐标
								w: fkkuan, //宽
								h: fkgao, //高
						      hp: renhp, //生命值
								isAI: bIsAI, //是否为机器人
								team: team, //队伍
								name: name, //名字
								dis: distance, //距离
								weaponid: weaponid, //手持枪械
								
								towards: towards, //人物朝向
								zt: StatusOffset, //人物状态
							
								localPlayer: localPlayerController, //本人地址
		
								//3dx
								
		
							};
							if (distance < app.dis) { //可调绘制范围
								shadowInfo(actorInfo);
							}
							if (bIsAI) {
								ai++;
							} else {
								playerCout++;
							}
						}
					}
		
					if (topEnemy > 0) {
						drawText(`❌空降敌人: ${topEnemy}`, sWidth / 2, sHeight / 8, 22, "yellow", "center", true);
					}
					//人数统计
					//drawRoundRect(sWidth / 2 - 90, 0 + app.renshu, 180, 38, 20, 'rgba(255,255,255,0.5)', true); //利用圆角矩形填充
					if (playerCout + ai > 0) {
						drawText("🚨", sWidth / 2, -30 + app.renshu, 25, "white", "center", true);
					}
					if (playerCout + ai < 1) {
						drawText("✔", sWidth / 2, -30 + app.renshu, 25, "white", "center", true);
					}
					drawText("🕴", sWidth / 2 - 60, -25 + app.renshu, 25, "white", "center", true);
					drawText("👽", sWidth / 2 + 62, -25 + app.renshu, 25, "white", "center", true);
					//真人总数
					drawText(playerCout, sWidth / 2 - 30, -20 + app.renshu, 20, playerCout > 0 ? "#f00" : "white", "center", true);
					//人机总数
					drawText(ai, sWidth / 2 + 32, -20 + app.renshu, 20, ai > 0 ? "lime" : "white", "center", true);
					
					//drawText(`坐标X: ${worldPos.X}`, sWidth / 2, sHeight / 2, 22, "red", "center", true);
		
		
		
		
		
		
				}
		
		
				function shadowInfo(objectInfo) {
					//人机判断 是的话对标变为AI
					if (objectInfo.isAI) objectInfo.team = "AI";
		
		
		
		
					//射线
					if (app.checkboxList.isLine) {
						color = "white";
						if (objectInfo.isAI) color = "#28ff1d";
						
						if (objectInfo.hp > 0) {
							
								drawLine(sWidth / 2, 34 + app.renshu, objectInfo.x, objectInfo.y - 44, color, 1);
							
						}
					}
		
		
					//超出屏幕只绘制射线 背敌
					if (objectInfo.x < 0 || objectInfo.y < 0 || objectInfo.x > sWidth || objectInfo.y > sHeight) {
						// 背敌
						if (app.checkboxList.isBeid) {
							if (objectInfo.x < 0) objectInfo.x = 20;
							if (objectInfo.y < 0) objectInfo.y = 20;
							if (objectInfo.x > sWidth) objectInfo.x = sWidth - 20;
							if (objectInfo.y > sHeight) objectInfo.y = sHeight - 20;
							drawCircular(objectInfo.x, objectInfo.y, 100, 15, objectInfo.isAI ? "rgba(0,255,0,0.6)" :
								"rgba(255,0,0,0.6)", true);
							drawText(`${objectInfo.dis}m`, objectInfo.x, objectInfo.y - 16, 10, "white", "center", true);
						}
						return
					}
		
					
						//方框
						if (app.checkboxList.isBox) {
						drawMyRect(objectInfo.x - objectInfo.w / 2, objectInfo.y, objectInfo.w, objectInfo.h, objectInfo.hp <=
									0 ? "yellow" : "#00ffff", false);
						} 
						
						//骨骼
				
		
						//距离
						if (app.checkboxList.isDis) {
							drawText("[" + objectInfo.dis + "m]", objectInfo.x, objectInfo.y - 53, 10, "97ffff", "right", true);
						}
		
						//信息
						if (app.checkboxList.isInfo) {
							const teamcolor = app.teamcolor[objectInfo.team];
							//倒三角形 开始点，x,y 途径，x,y 终点，x,y
							drawTriangle(objectInfo.x - 3, objectInfo.y - 12, objectInfo.x, objectInfo.y - 6, objectInfo.x + 3,
								objectInfo.y - 12, teamcolor, 0.5, true);
							//队标背景
							drawRectangle(objectInfo.x - 46, objectInfo.y - 29, 16, 14, teamcolor, 0.8, true);
							//名字背景
							drawRectangle(objectInfo.x - 30, objectInfo.y - 29, 75, 14, teamcolor, 0.5, true);
							//队标文字
							drawText(objectInfo.team, objectInfo.x - 38, objectInfo.y - 38, 10, "#FFF", "center", true);
							//名字文字
							if (objectInfo.name.length > 7) objectInfo.name = `${objectInfo.name.slice(0, 6)}...`
							drawText(objectInfo.name, objectInfo.x + 8, objectInfo.y - 38, 10, "#FFF", "center", true);
						}
		
						//血量
						if (app.checkboxList.isHP) {
							//绘制圆角矩形，起点xy，矩形宽高，圆角半径，颜色，是否填充矩形
		
							drawRect(objectInfo.x - 46, objectInfo.y - 15, 91, 3,  "rgba(0,0,0,0.4)", true);
							drawRect(objectInfo.x - 46, objectInfo.y - 15, Math.ceil(objectInfo.hp / 1.1), 3,  objectInfo.hp <= 30 ? "rgba(255,0,0,0.8)" : "rgba(255,255,255,0.8)", true);
						}
		
					
						//手持
						if (0) {
							
							const shouchi = app.shouchi[objectInfo.weaponid];
							if (objectInfo.hp > 0) {
								drawText("[还没写]", objectInfo.x, objectInfo.y - 53, 10, "97ffff", "left", true);
							} else if (objectInfo.hp <= 0) {
								drawText("[倒地]", objectInfo.x, objectInfo.y - 53, 10, "97ffff", "left", true);
							}
						}					
				}
		
				//********************* 追踪相关 ****************
		
	
		
				// ********************* 绘图相关 *********************
		
				//清空画布
				function clearCtx() {
					ctx.clearRect(0, 0, canvasDom.width, canvasDom.height);
				}
		
				//设置线宽
				function setLineWidth(w) {
					ctx.lineWidth = w;
				}
		
				//绘制图片测试
				function circleImgTwo(img, x, y, w, h) {
					x *= iosScale;
					y *= iosScale;
					w *= iosScale;
					h *= iosScale;
					ctx.globalAlpha = 0.8;
					ctx.drawImage(img, x, y, w, h);
				}
		
				//绘制圆形带箭头 中心点xy,半径, 箭头旋转角度, 圆形颜色，箭头颜色（雷达点朝向）
				function drawCMark(x, y, radius, angle, cColor, dColor) {
					x *= iosScale;
					y *= iosScale;
					radius *= iosScale;
		
					var startAngle = (Math.PI / 180) * (-30 + angle);
					var endAngle = (Math.PI / 180) * (30 + angle);
		
					//圆形
					ctx.beginPath();
					ctx.fillStyle = cColor;
					ctx.arc(x, y, radius, 0, 360, false);
					ctx.fill();
					ctx.closePath();
		
					//箭头
					ctx.beginPath();
					ctx.fillStyle = dColor;
					ctx.arc(x, y, radius + radius * 0.15, startAngle, endAngle, false);
		
					var rx = x + (x + radius * 1.7 - x) * Math.cos(angle * Math.PI / 180) - (y - y) * Math.sin(angle * Math.PI / 180);
					var ry = y + (x + radius * 1.7 - x) * Math.sin(angle * Math.PI / 180) + (y - y) * Math.cos(angle * Math.PI / 180);
		
					ctx.lineTo(rx, ry);
					ctx.fill();
					ctx.closePath();
				}
		
				//绘制三角形，起始点xy，终点xy，颜色，透明度，是否填充
				function drawTriangle(x1, y1, x2, y2, x3, y3, color, globalAlpha, isFill = true) {
					x1 *= iosScale;
					y1 *= iosScale;
					x2 *= iosScale;
					y2 *= iosScale;
					x3 *= iosScale;
					y3 *= iosScale;
		
					//三角形
					ctx.beginPath(); //开始绘制
					ctx.strokeStyle = color;
					ctx.fillStyle = color;
					ctx.globalAlpha = globalAlpha;
					ctx.moveTo(x1, y1); //开始点，设置x,y
					ctx.lineTo(x2, y2); //途经点，设置x,y
					ctx.lineTo(x3, y3); //最终点，设置x,y
					ctx.closePath(); //闭合路径
					if (isFill) {
						ctx.fill(); //绘制实心
					} else {
						ctx.stroke(); //绘制空心
					}
				}
		
				//绘制对角矩形 起点xy，矩形宽高，颜色，是否填充（对角方框）
				function drawMyRect(x, y, w, h, color, isFill = true) {
					x *= iosScale;
					y *= iosScale;
					w *= iosScale;
					h *= iosScale;
		
					ctx.strokeStyle = color;
					ctx.lineWidth = app.xian;
		
					ctx.beginPath();
		
					ctx.moveTo(x, y);
					ctx.lineTo(Number(x) + Number(w) / 6, y);
					ctx.closePath();
		
					ctx.moveTo(x, y);
					ctx.lineTo(x, Number(y) + Number(h / 6));
					ctx.closePath();
		
					ctx.moveTo(Number(x) + Number(w) - Number(w) / 6, y);
					ctx.lineTo(Number(x) + Number(w), y);
					ctx.closePath();
		
					ctx.moveTo(Number(x) + Number(w), y);
					ctx.lineTo(Number(x) + Number(w), Number(y) + Number(h / 6));
					ctx.closePath();
		
					ctx.moveTo(Number(x), Number(y) + Number(h));
					ctx.lineTo(Number(x), Number(y) + Number(h) - Number(h / 6));
					ctx.closePath();
		
					ctx.moveTo(Number(x), Number(y) + Number(h));
					ctx.lineTo(Number(x) + Number(w) / 6, Number(y) + Number(h));
		
					ctx.moveTo(Number(x) + Number(w), Number(y) + Number(h));
					ctx.lineTo(Number(x) + Number(w) - (w / 6), Number(y) + Number(h));
		
					ctx.moveTo(Number(x) + Number(w), Number(y) + Number(h));
					ctx.lineTo(Number(x) + Number(w), Number(y) + Number(h) - Number(h / 6));
					ctx.closePath();
					ctx.stroke();
				}
		
			
		
				//绘制矩形 起点xy，矩形宽高，颜色，透明度，是否填充矩形（队标、名字背景）
				function drawRectangle(x, y, w, h, color, transparency, isFill = true) {
					x *= iosScale;
					y *= iosScale;
					w *= iosScale;
					h *= iosScale;
		
					ctx.beginPath();
					ctx.fillStyle = color;
					ctx.globalAlpha = transparency;
					ctx.fillRect(x, y, w, h, );
					ctx.closePath();
				}
		
				//绘制线条，起始点xy，终点xy，颜色（雷达线条、射线、3D框线条）
				function drawLine(x1, y1, x2, y2, color, lineWidth) {
					x1 *= iosScale;
					y1 *= iosScale;
					x2 *= iosScale;
					y2 *= iosScale;
		
					ctx.beginPath();
					ctx.lineWidth = lineWidth;
					ctx.fillStyle = color;
					ctx.strokeStyle = color;
					ctx.moveTo(x1, y1);
					ctx.lineTo(x2, y2);
					ctx.stroke();
					ctx.closePath();
				}
		
				//绘制圆形 起点xy，圆形弧度，大小，颜色，线宽，是否填充（简洁风格血条、雷达、背敌）
				function drawCircular(x, y, num, size, color, lineWidth, isFill = true) {
					x *= iosScale;
					y *= iosScale;
					size *= iosScale;
		
					if (num === 100) num = 1;
					else if (num > 0) num = 1 - num / 100;
					const d2a = n => n * Math.PI / 180;
		
					ctx.beginPath();
					ctx.lineWidth = lineWidth;
					ctx.arc(x, y, size, d2a(num * 360 - 90), d2a(-90), false);
					if (isFill) {
						ctx.fillStyle = color;
						ctx.fill();
					} else {
						ctx.strokeStyle = color;
						ctx.stroke();
					}
					ctx.closePath();
				}
		
				//绘制矩形 起点xy，矩形宽高，颜色，是否填充矩形 (方框)
				function drawRect(x, y, w, h, color, isFill = true) {
					x *= iosScale;
					y *= iosScale;
					w *= iosScale;
					h *= iosScale;
		
					ctx.beginPath();
					ctx.lineWidth = app.xian;
					ctx.strokeStyle = color;
					ctx.fillStyle = color;
					ctx.globalAlpha = 1;
					if (isFill) {
						ctx.fillRect(x, y, w, h);
					} else {
						ctx.strokeRect(x, y, w, h);
					}
					ctx.closePath();
				}
		
				//绘制圆角矩形，起点xy，矩形宽高，圆角半径，颜色，是否填充矩形
				function drawRoundRect(x, y, w, h, r, color, isFill = true) {
					x *= iosScale;
					y *= iosScale;
					w *= iosScale;
					h *= iosScale;
					r *= iosScale;
		
					ctx.beginPath();
					ctx.strokeStyle = color;
					ctx.fillStyle = color;
					ctx.globalAlpha = 1;
					if (w < 2 * r) r = w / 2;
					if (h < 2 * r) r = h / 2;
					ctx.beginPath();
					ctx.moveTo(x + r, y);
					ctx.arcTo(x + w, y, x + w, y + h, r);
					ctx.arcTo(x + w, y + h, x, y + h, r);
					ctx.arcTo(x, y + h, x, y, r);
					ctx.arcTo(x, y, x + w, y, r);
					if (isFill) {
						ctx.fill();
					} else {
						ctx.stroke();
					}
					ctx.closePath();
				}
		
				//绘制文字，文字内容，起点xy，文字大小，文字对齐，颜色，是否填充文字
				function drawText(text, x, y, size, color, textAlign, isFill = true) {
					x *= iosScale;
					y *= iosScale;
					size *= iosScale;
		
					ctx.beginPath();
					ctx.globalAlpha = 1; //透明度
					ctx.textAlign = textAlign; //文字对齐
					ctx.fillStyle = color;
					ctx.strokeStyle = color;
					ctx.font = size + 'px' + fontFamily;
					if (isFill) {
						ctx.fillText(text, x, y + size);
					} else {
						ctx.strokeText(text, x, y + size);
					}
					ctx.closePath();
				};
		
				// ********************* 内存相关 *********************
				function readInt(addr) {
					return Number(h5gg.getValue(addr, "I32"));
				}
		
				function readLong(addr) {
					return Number(h5gg.getValue(addr, "I64"));
				}
		
				function readFloat(addr) {
					return Number(h5gg.getValue(addr, "F32"));
				}
		
				function isNull(addr) {
					return (addr < 0x100000000 || addr > 0x300000000);
				}
		
				// ********************* UE4相关 *********************
				function RotatorToMatrix(rotation) {
					var radPitch = rotation.Pitch * (Math.PI / 180.0);
					var radYaw = rotation.Yaw * (Math.PI / 180.0);
					var radRoll = rotation.Roll * (Math.PI / 180.0);
		
					var SP = Math.sin(radPitch);
					var CP = Math.cos(radPitch);
					var SY = Math.sin(radYaw);
					var CY = Math.cos(radYaw);
					var SR = Math.sin(radRoll);
					var CR = Math.cos(radRoll);
		
					var matrix = new Array(16).fill(0);
		
					matrix[0] = (CP * CY);
					matrix[1] = (CP * SY);
					matrix[2] = (SP);
					matrix[3] = 0;
		
					matrix[4] = (SR * SP * CY - CR * SY);
					matrix[5] = (SR * SP * SY + CR * CY);
					matrix[6] = (-SR * CP);
					matrix[7] = 0;
		
					matrix[8] = (-(CR * SP * CY + SR * SY));
					matrix[9] = (CY * SR - CR * SP * SY);
					matrix[10] = (CR * CP);
					matrix[11] = 0;
		
					matrix[12] = 0;
					matrix[13] = 0;
					matrix[14] = 0;
					matrix[15] = 1;
		
					return matrix;
				}
		
				function vectorDot(lhs, rhs) {
					return (((lhs.X * rhs.X) + (lhs.Y * rhs.Y)) + (lhs.Z * rhs.Z));
				}
		
				function world2Screen(worldLocation, camViewInfo, tempMatrix) {
					// var tempMatrix = RotatorToMatrix(camViewInfo.Rotation);
		
					var vAxisX = {
						X: tempMatrix[0],
						Y: tempMatrix[1],
						Z: tempMatrix[2]
					};
		
					var vAxisY = {
						X: tempMatrix[4],
						Y: tempMatrix[5],
						Z: tempMatrix[6]
					};
		
					var vAxisZ = {
						X: tempMatrix[8],
						Y: tempMatrix[9],
						Z: tempMatrix[10]
					};
		
					var vDelta = {
						X: worldLocation.X - camViewInfo.Location.X,
						Y: worldLocation.Y - camViewInfo.Location.Y,
						Z: worldLocation.Z - camViewInfo.Location.Z
					};
		
					var vTransformed = {
						X: vectorDot(vDelta, vAxisY),
						Y: vectorDot(vDelta, vAxisZ),
						Z: vectorDot(vDelta, vAxisX)
					};
		
					if (vTransformed.Z < 1.0) {
						vTransformed.Z = 1.0;
					}
		
					var fov = camViewInfo.FOV;
					var screenCenterX = (sWidth / 2.0);
					var screenCenterY = (sHeight / 2.0);
		
					var re = {
						X: (screenCenterX + vTransformed.X * (screenCenterX / Math.tan(fov * (Math.PI / 360.0))) / vTransformed
							.Z),
						Y: (screenCenterY - vTransformed.Y * (screenCenterX / Math.tan(fov * (Math.PI / 360.0))) / vTransformed.Z)
					};
		
					return re;
				};
		
	
				cacheTimer = setInterval(function() {
					drawCache();
				}, 3000); //一秒缓存一次
		
				drawTimer = setInterval(function() {
					if (app.checkboxList.isDraw == '1') {
						//console.log("1");
						shadowDraw();
		
						//计算FPS
						if (!window.fpscount) window.fpscount = 0;
						if (!window.fpstime) window.fpstime = performance.now();
						window.fpscount++;
						if ((performance.now() - window.fpstime) > 2000) {
							window.fps = window.fpscount;
							window.fpstime = performance.now();
							window.fpscount = 0;
						}
						ctx.textBaseline = "top";
						ctx.textAlign = "center";
						ctx.font = '40px "Arial, sans-serif"';
						ctx.fillStyle = "aqua";
		
						if (window.fps) ctx.fillText("FPS: " + window.fps, 150, 50);
					} else {
						clearCtx();
					}
				}, app.fps);
	</script>
</html>